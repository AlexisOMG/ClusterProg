Федеральное государственное бюджетное образовательное учреждение
высшего профессионального образования
«Московский государственный технический университет имени Н. Э. Баумана»
(МГТУ им. Н. Э. Баумана)



Факультет: Информатика и системы управления

Кафедра: Теоретическая информатика и компьютерные технологии







Лабораторная работа №1
«Разработка ftp клиента, ftp сервера и их совместная работа»
по курсу: «КОМПЬЮТЕРНЫЕ СЕТИ»






Выполнил:
Студент группы ИУ9-32Б
Жук Д. О.

Проверил: 
Посевин Д. П.


 
1.	Цель.
Целью данной лабораторной работы является: разработка ftp-клиента на языке GO на основе пакета github.com/jlaffaye/ftp (main1.go), разработка ftp-сервера на языке GO на основе пакетов github.com/goftp/file-driver, github.com/goftp/server (main2.go) и интеграция результатов работ.
2.	Условия задачи.
Реализовать на языке GO и запустить ftp-сервер на одном из серверов, далее запустить go ftp-клиент либо на другом сервере, либо на одном и том же сервере, но обращаясь к localhost. 
Разработать клиент-серверное приложение для автоматизации передачи данных с одного сервера на другой с использованием GO ftp-клиента и GO ftp-сервера. Необходимо реализовать выполнение следующих функций с помощью ftp-клиента:
- поддерживать авторизацию клиента на ftp-сервере;
- передавать клиенту список содержимого заданной директории ftp-сервера по запросу;
- позволять клиенту скачивать файлы из заданной директории ftp-сервера по запросу;
- позволять клиенту загружать файлы в заданную директорию ftp-сервера по запросу;
- позволять клиенту создавать директории на ftp-сервере по запросу;	
- позволять клиенту удалять директории на ftp-сервере по запросу.   
main1.go
package main

import (
   "bufio"
   "bytes"
   "fmt"
   "io/ioutil"
   "log"
   "os"
   "path"
   "strings"

   "github.com/jlaffaye/ftp"
)

type client struct {
   server   string
   login    string
   password string
   conn     *ftp.ServerConn
}

func (obj *client) CreateConnection() {
   conn, err := ftp.Dial(obj.server)
   obj.conn = conn
   if err != nil {
      log.Fatal("Connection: ", err)
   }
   err = obj.conn.Login(obj.login, obj.password)
   if err != nil {
      log.Fatal("Login: ", err)
   }
}

func (obj *client) StoreFile(pathLocal, pathRemote string) {
   dir := path.Dir(pathRemote)
   file := path.Base(pathRemote)
   fmt.Println(dir)
   err := obj.conn.ChangeDir(dir)
   if err != nil {
      log.Fatal("ChangeDir: ", err)
   }
   content, err := ioutil.ReadFile(pathLocal)
   if err != nil {
      log.Fatal("Read local file: ", err)
   }
   data := bytes.NewBuffer(content)
   err = obj.conn.Stor(file, data)
   if err != nil {
      log.Fatal("Stor: ", err)
   }

   err = obj.conn.ChangeDirToParent()
   if err != nil {
      log.Fatal("ChangeDirToParent: ", err)
   }
}

func (obj *client) LoadFile(pathRemote string) {
   _, file := path.Split(pathRemote)
   r, err := obj.conn.Retr(pathRemote)
   if err != nil {
      log.Fatal("Retr: ", err)
   }
   buf, err := ioutil.ReadAll(r)
   if err != nil {
      log.Fatal("ReadAll: ", err)
   }
   err = ioutil.WriteFile(file, buf, 0644)
   if err != nil {
      log.Fatal("WriteFile: ", err)
   }
   fmt.Println(string(buf))
   r.Close()
}

func (obj *client) CreateDir(path string) {
   err := obj.conn.MakeDir(path)
   if err != nil {
      log.Fatal("MakeDir: ", err)
   }
}

func (obj *client) DeleteFile(pathRemote string) {
   err := obj.conn.Delete(pathRemote)
   if err != nil {
      log.Fatal("Delete: ", err)
   }
}

func (obj *client) ReadDir(dir string) {
   entry, err := obj.conn.List(dir)
   if err != nil {
      log.Fatal("List: ", err)
   }
   for _, el := range entry {
      fmt.Println(el.Name)
   }
}

func (obj *client) DeleteDir(pathRemote string) {
   err := obj.conn.RemoveDir(pathRemote)
   if err != nil {
      log.Fatal("RemoveDir: ", err)
   }
}

func main() {
   var cl client
   fmt.Print("Enter server address:\t  ")
   fmt.Scanf("%s", &cl.server)
   fmt.Print("Enter login:\t\t  ")
   fmt.Scanf("%s", &cl.login)
   fmt.Print("Enter password:\t\t  ")
   fmt.Scanf("%s", &cl.password)
   // cl.server = "students.yss.su:21"
   // cl.login = "ftpiu8"
   // cl.password = "3Ru7yOTA"
   cl.CreateConnection()
   defer cl.conn.Quit()
   in := bufio.NewReader(os.Stdin)
   for {
      fmt.Print("\t\t\t> ")
      cmd, _ := in.ReadString('\n')
      comm := strings.Split(cmd, " ")
      comm[len(comm)-1] = strings.Trim(comm[len(comm)-1], "\n")
      if comm[0] == "touch" {
         cl.StoreFile(string(comm[1]), string(comm[2]))
      } else if comm[0] == "cat" {
         cl.LoadFile(string(comm[1]))
      } else if comm[0] == "mkdir" {
         cl.CreateDir(string(comm[1]))
      } else if comm[0] == "rm" {
         cl.DeleteFile(string(comm[1]))
      } else if comm[0] == "ls" {
         cl.ReadDir(string(comm[1]))
      } else if comm[0] == "rmdir" {
         cl.DeleteDir(string(comm[1]))
      } else if comm[0] == "exit" {
         fmt.Printf("Connection to %s closed\n", cl.server)
         break
      } else {
         fmt.Printf("%s: command not found\n", comm[0])
      }
   }
}


 
main2.go

package main

import (
   "log"

   "goftp.io/server/core"
   "goftp.io/server/driver/file"
)

func main() {
   factory := &file.DriverFactory{
      RootPath: "./server",
      Perm:     core.NewSimplePerm("zhuk", "zhuk"),
   }
   auth := &core.SimpleAuth{
      Name:     "zhuk",
      Password: "zhuk",
   }
   opts := &core.ServerOpts{
      Auth:    auth,
      Factory: factory,
      Port:    3012,
   }
   server := core.NewServer(opts)
   err := server.ListenAndServe()
   if err != nil {
      log.Fatal("Run server: ", err)
   }
}
 

3.	Результаты выполнения
 
