Федеральное государственное бюджетное образовательное учреждение
высшего профессионального образования
«Московский государственный технический университет имени    Н. Э. Баумана»
(МГТУ им. Н. Э. Баумана)



Факультет: Информатика и системы управления

Кафедра: Теоретическая информатика и компьютерные технологии







Лабораторная работа №2
«Разработка ssh клиента, ssh сервера и их совместная работа»
по курсу: «КОМПЬЮТЕРНЫЕ СЕТИ»






Выполнил:
Студент группы ИУ9-32Б
Жук Д. О.

Проверил: 
Посевин Д. П.


 
1.	Цель.
Целью данной лабораторной работы является: разработка ssh-клиента на языке GO на основе пакета golang.org/x/crypto/ssh (main1.go), разработка ssh-сервера на языке GO на основе пакета github.com/gliderlabs/ssh (main2.go) и интеграция результатов работ с возможностью подключения одного клиентам к нескольким серверам (main3.go).
2.	Условия задачи.
Реализовать на языке GO и запустить ssh-сервер на одном из серверов, далее запустить GO ssh-клиент либо на другом сервере, либо на одном и том же сервере, но обращаясь к localhost. 
Разработать клиент-серверное приложение для автоматизации передачи данных с одного сервера на другой с использованием GO ssh-клиента и GO ssh-сервера. Необходимо реализовать выполнение следующих функций с помощью ftp-клиента:
- создание директории на удаленном go ssh сервере из go ssh клиента;
- удаление директории на удаленном go ssh сервере из go ssh клиента;
- выполнить удаленно приложение на ssh сервере посредством ssh клиента.
main1.go
package main

import (
    "bufio"
    "fmt"
    "log"
    "os"
    "strings"

    "golang.org/x/crypto/ssh"
)

type client struct {
    server   string
    login    string
    password string
}

func main() {
    var cl client
    fmt.Print("Enter server address:\t  ")
    fmt.Scanf("%s", &cl.server)
    fmt.Print("Enter login:\t\t  ")
    fmt.Scanf("%s", &cl.login)
    fmt.Print("Enter password:\t\t  ")
    fmt.Scanf("%s", &cl.password)

    сonfig := &ssh.ClientConfig{
        User: cl.login,
        Auth: []ssh.AuthMethod{
            ssh.Password(cl.password),
        },
        HostKeyCallback: ssh.InsecureIgnoreHostKey(),
    }

    connection, err := ssh.Dial("tcp", cl.server, сonfig)
    if err != nil {
        panic(err)
    }

    session, err := connection.NewSession()
    if err != nil {
        panic(err)
    }
    defer session.Close()

    stdin, err := session.StdinPipe()
    if err != nil {
        log.Fatal(err)
    }

    session.Stdout = os.Stdout
    session.Stderr = os.Stderr

    err = session.Shell()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(strings.Repeat("=", 50))
    fmt.Println("Start new session in", cl.server)
    in := bufio.NewReader(os.Stdin)
    for {
        fmt.Println(strings.Repeat("=", 50))
        inp, _, _ := in.ReadLine()
        cmd := string(inp)
        if cmd == "exit" {
            break
        }
        stdin.Write([]byte(cmd + "\n"))
    }
    fmt.Println(strings.Repeat("=", 50))
    fmt.Println("Cloze session in", cl.server)
}

main2.go

package main

import (
    "bufio"
    "fmt"
    "io"
    "log"
    "os/exec"
    "strings"

    "github.com/gliderlabs/ssh"
)

var allUsers = map[string]string{
    "zhuk": "zhuk",
    "root": "pass123",
}

func main() {
    log.Fatal(ssh.ListenAndServe(":3012",
        func(s ssh.Session) {
            log.Println("Terminal:")
            for {
                line, err := bufio.NewReader(s).ReadString('\n')
                if err != nil {
                    break
                }
                in := strings.Split(line[:len(line)-1], " ")
                if in[0] == "" {
                    continue
                }
                if in[0] == "exit" {
                    break
                }
                exe := exec.Command(in[0], in[1:]...)
                out, err := exe.Output()
                if err != nil {
                    log.Println(err)
                }
                io.WriteString(s, fmt.Sprintf("%s\n", out))
            }
            log.Println("session closed")
        },
        ssh.PasswordAuth(func(context ssh.Context, password string) bool {
            truePassword, found := allUsers[context.User()]
            return found && password == truePassword
        }),
    ))
}

main3.go

package main

import (
    "bufio"
    "fmt"
    "io"
    "log"
    "os"
    "strings"

    "golang.org/x/crypto/ssh"
)

type client struct {
    server   string
    login    string
    password string
}

var allServer = [2]client{
    {"lab2.posevin.com:22", "zhuk", "89637373707"},
    {"localhost:3012", "zhuk", "zhuk"},
}

func connect(cl client) (ans io.WriteCloser) {
    сonfig := &ssh.ClientConfig{
        User: cl.login,
        Auth: []ssh.AuthMethod{
            ssh.Password(cl.password),
        },
        HostKeyCallback: ssh.InsecureIgnoreHostKey(),
    }

    connection, err := ssh.Dial("tcp", cl.server, сonfig)
    if err != nil {
        panic(err)
    }

    session, err := connection.NewSession()
    if err != nil {
        panic(err)
    }
    // defer session.Close()

    stdin, err := session.StdinPipe()
    if err != nil {
        log.Fatal(err)
    }

    session.Stdout = os.Stdout
    session.Stderr = os.Stderr

    err = session.Shell()
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(strings.Repeat("=", 50))
    fmt.Println("Start new session in", cl.server)

    return stdin
}

func main() {
    var allStdin []io.WriteCloser
    for _, cl := range allServer {
        allStdin = append(allStdin, connect(cl))
    }
    in := bufio.NewReader(os.Stdin)
    for {
        inp, _, _ := in.ReadLine()
        cmd := string(inp)
        if cmd == "exit" {
            break
        }
        for _, stdin := range allStdin {
            fmt.Println(strings.Repeat("=", 50))
            go stdin.Write([]byte(cmd + "\n"))
        }
    }
}

 


3.	Результаты выполнения
 
