
Министерство образования и науки Российской Федерации
Федеральное государственное бюджетное образовательное учреждение 
высшего образования
«Московский государственный технический университет
имени Н.Э. Баумана
(национальный исследовательский университет)»
(МГТУ им. Н.Э. Баумана)


ФАКУЛЬТЕТ ___________________________________________________________________

КАФЕДРА ______________________________________________________________________



ОТЧЕТ ПО УЧЕБНОЙ 
ПРАКТИКЕ


Студент_____________________________________________________________
фамилия, имя, отчество

Группа___________________

Тип практики ________________________________________________________

Название предприятия_________________________________________________________



Студент					_________________  ____________________ 
				         подпись, дата                   фамилия, и.о.            

Руководитель практики			_________________  ____________________ 
				         подпись, дата                   фамилия, и.о.            



Оценка  __________________________________   







20      г.

Оглавление
Введение	2
Цели практики	2
Поставленные задачи	3
Отчёт о выполнении практики	3
Характеристика организации	3
Применяемые практики	4
Система контроля версий	4
Покрытие кода тестами	4
Стиль кода	4
CI/CD	4
Технологический стек	5
Разработанная система формул	5
Парсинг формул	5
Как определить формулу	6
Операторы	6
Математические	6
Логические	6
Функции	6
Математические	6
Логические	7
Перехода	7
Интервалы	7
Интервальные функции	7
Функции, поддерживающие интервалы	7
Мой вклад	7
Парсинг формул	7
Планирование	7
Код	8
Модуль вычислений	8
Планирование	8
Код	9
Зависимость вычислений	9
Планирование	9
Код	9
Заключение	9
Выполненные задачи	9
Невыполненные задачи	9
Дальнейшее развитие проекта	10

Введение
Цели практики
При выполнении практики были поставлены следующие цели:
1.	Развить навыки командной работы
2.	Получить представление о системах контроля версий в общем и git в частности
3.	Ознакомиться с процессом построения современных веб-ориентированных клиентских и клиент-серверных приложений
4.	На практике получить навыки работы с языком JavaScript и его экосистемой
5.	Получить опыт разработки с применением системы контроля версий и code review
Поставленные задачи
Перед всеми участниками практики была поставлена задача разработки клиентского или клиент-серверного приложения выбранной тематики. В качестве языка для реализации требовалось использовать JavaScript. При разработке серверной части платформу Node.js.
Наша команда выбрала в качестве тематики проекта систему электронных таблиц. 
Вот основные функции, которые должны были присутствовать в полученном приложении:
1.	Наличие интерфейса, позволяющего редактировать значения в ячейках электронной таблицы
2.	Возможность менять параметры ячеек, такие как шрифт текста, цвет заливки
3.	Наличие системы формул, позволяющей выполнять различные вычислительные операции на основании данных из ячеек
4.	Возможность хранения таблиц на сервере

Отчёт о выполнении практики
Характеристика организации
Ниже представлен перечень участников команды и роли, которые они выполняли.
Участник	Роль в команде	Профиль на GitHub
Абдулзагир Шахманаев	Дизайнер, frontend разработчик	https://github.com/shehamane

Алексей Егоров	Backend разработчик	https://github.com/AlexisOMG

Артём Белоусов	Капитан команды, backend разработчик	https://github.com/flygrounder

Динара Абдраманова	Дизайнер, frontend разработчик	https://github.com/avonamardba

Дмитрий Жук	Разработчик вычислительного модуля	https://github.com/ZhukDima

Милана Кондакова	Backend разработчик	https://github.com/MKondakova

Применяемые практики
Система контроля версий
При разработке использовался подход Github flow . При разработке новой функции создавалась новая ветка. Над ней мог работать как один разработчик, так и несколько. После того, как разработчики считали, что разрабатываемая функция готова, открывался Pull Request и проводился Code Review. Обычно его проводил капитан, но другие участники также могли участвовать. Решение о слиянии принималось капитаном на основании проведённых Code Review.
Покрытие кода тестами
Для уменьшения количества ошибок в разрабатываемой программе и для проверки корректности её работы, применялось Unit тестирование . В целях проверки полноты тестирования измерялось покрытие c помощью библиотеки c8 . Ниже представлено покрытие тестами ветки master на момент 27.09.2020.
-------------------------------|---------|----------|---------|---------|-------
File                           | % Stmts | % Branch | % Funcs | % Lines |       
-------------------------------|---------|----------|---------|---------|-------
All files                      |    75.5 |     97.2 |   91.58 |    75.5 |       
Стиль кода
За основу стиля кода для JavaScript было взято руководство Airbnb . Некоторые правила были изменены по практическим причинам. Для проверки кода на соответствие стилю использовалась программа ESlint . 
Для проверки стиля CSS кода использовалась программа stylelint  со стандартными настройками.
CI/CD
Для ускорения цикла обратной связи применялась практика CI/CD . За непрерывную интеграцию отвечала служба Github Actions, в которой выполнялась проверка стиля кода, запускались юнит тесты. Если какая-либо проверка завершалась неудачей, то возможность слияния Pull Request блокировалась до тех пор, пока обнаруженные проблемы не были исправлены.
Для сборки проекта и развёртывания на сервере применялась программа Jenkins . Результат сборки доступен по адресу https://unitables.flygrounder.ru/
Технологический стек
Ниже перечислены использованные технологии с объяснением целесообразности их применения:
1.	JavaScript — язык программирования как для клиентской части, так и для серверной. Был выбран в соответствии с условиями прохождения практики.
2.	Node.js использовался в качестве программной платформы как для серверной части, так и для сборки клиентской.
3.	Express  - фреймворк для написания серверной части. Был выбран за счёт минималистичности и расширяемости.
4.	Sqlite3  - файловая база данных. Выбрана благодаря простоте настройки и развёртывания. 
5.	Docker  - технология контейнеризации. Используется по причине возможности установки новых версий Node.js без возникновения конфликтов со старыми. Кроме того, благодаря применению этой технологии сборки стали воспроизводимыми и ошибки, найденные после развёртывания, стало легче обнаруживать.
6.	Webpack  - программа для сборки JavaScript приложений. Благодаря её использованию стало возможно повторное использование кода между клиентом и сервером. Кроме того, в клиентской части появилась возможность использовать node модули.
Разработанная система формул
В соответствии с задачей 3 была разработана система формул, позволяющая производить различные вычислительные операции на основании данных в ячейках таблицы.
Парсинг формул
Для разбора формул была разработана LL(1) грамматика и был разработан нисходящий парсер.
Ниже приведена грамматика:
<Block> 	::= =<Equals> | value.
<Equals> 	::= <Exrp><_Equals> 
<_Equals> 	::= EqOp <Expr> | .
<Expr> 	::= <Term><_Expr>.
<_Expr>	::= AddOp <Term><_Expr> | .
<Term>	::= <Factor> <_Term> .
<_Term>   	::= MulOp <Factor> <_Term> | .
<Factor>  	::= <Power> <_Factor> .
<_Factor> 	::= PowOp <Power> <_Factor> | .
<Power>   	::= value | (<Expr>) | unaryMinus Power | NameFunc (<Args> .
<Args> 	::= <Expr><_Args> | ) .
<_Args> 	::= ;<Expr><_Args> | ) .

EqOp 		::= == | >= | > | <= | < | !=
AddOp 	::= + | - .
MulOp 	::= * | / | % .
PowOp 	::= ^ .
unaryMinus	::= - .
NameFunc 	::= название функции .
value 	::= числа, строки, адреса, интервалы.
number: 	[0-9*]
string: 	“...”
address: 	($)[A-Z*]($)[0-9*]
interval: 	address:address
Как определить формулу
Любое выражение, начинающееся с « = » считается формулой.
Операторы
Математические
a + b	сумма чисел a и b
a - b	разность чисел a и b
- a	число, противоположное числу a
a * b	произведение чисел a и b
a / b	частное чисел a и b
a ^ b	число a в степени b
a % b	остаток при делении числа a на число b
Логические
a == b	a равно b
a >= b	a больше или равно b
a > b	a больше b
a <= b	a меньше или равно b
a < b	a меньше b
a != b	a не равно b
Функции
Математические
СУММА(a1;a2;...)	сумма чисел a1, a2, ...
ПРОИЗВЕД(a1;a2;...)	произведение чисел a1, a2, ...
МОД(a)	модуль числа a
МИН(a1;a2;...)	минимум чисел a1, a2, ...
МАКС(a1;a2;...)	максимум чисел a1, a2, ...
КОРЕНЬ(a)	квадратный корень из числа a

Логические
НЕ(a) - логическое отрицание выражения a
И(a1;a2;...) - логическое "и" выражений a1, a2, ...
ИЛИ(a1;a2;...) - логическое "или" выражений a1, a2, ...
ИСКЛИЛИ(a;b) - логическое исключающее или выражений a и b
Перехода
ЕСЛИ(a;b;c) - возвращает b если условие a истинно, иначе возвращает c
Интервалы
Интервал - прямоугольник из ячеек, заданный своими угловыми ячейками. Например C4:F9 - прямоугольник с углами в ячейках C4 и F9.
Интервальные функции
СЧЁТ(a) - количество непустых ячеек из интервала a
СЧЁТЕСЛИ(a;b) - число ячеек из интервала a со значением b
Функции, поддерживающие интервалы
Аргументы следующих функций, описанных ранее, могут быть интервалами:
•	СУММА
•	ПРОИЗВЕД
•	МИН
•	МАКС
Мой вклад
Занимаясь разработкой вычислительного аппарата нашего приложения, мной было решено множество задач и подзадач.
Парсинг формул
Планирование
Синтаксис выражений было решено взять на подобии Microsoft Excel – название функций состоит из больших русских букв, аргументы пишутся после в круглых скобках, отделяются друг от друга точкой с запятой, синтаксис математических выражений – классический: первый аргумент, оператор, второй аргумент. Мной была разработана БНФ грамматика, которая описана выше.
Код
При написании кода, для решения этой задачи, было создана два исполняющих файла: Parser.js и ExpressionWrapper.js. Задача первого – заниматься непосредственным разложением строки-формулы в дерево разбора, посредством вызова функций из второго файла, а второго – конкретизировать понятие дерева разбора.
Модуль вычислений
Планирование
Имея возможность производить парсинг выражений, нужно было научить программу по дереву разбора получать значения данного выражения. Было решено до последнего поддерживать возможность не просто масштабирования, а именно «простого» масштабирования – чтобы добавления нового типа значений или новой функции не приводило к экспоненциальному росту длины кода. Было решено что для этого будет использована идея хранить все функции в Map, у переменных отказаться от авто-приведения одного типа к другому и стандартных операций между разными типами переменных (нет умножения строки на число). 

Часть кода из файла TreeRunner.js
const libFunc = new Map([
  // ...

  ['+', (treeRunner) => {
    const res1 = treeRunner.makeTreeRunner(treeRunner.tree[1]).run();
    const res2 = treeRunner.makeTreeRunner(treeRunner.tree[2]).run();
    return res1.sum(res2);
  }],

  // ...
]);

export default class TreeRunner {
  // ...

  run() {
    if (!libFunc.has(this.tree[0])) {
      throw new FormatError(`undefined function ${this.tree[0]}`);
    }
    return libFunc.get(this.tree[0])(this);
  }
}
Код
При написании кода, для решения этой задачи, были созданы такие файлы: для вызова по дереву разбора каждой функции и расчета их аргументов (TreeRunner.js), «надстройка» для общего вызова первого файла (Calculator.js), файлы, создающие типы переменных, кроме самих значений знают как должны (или не должны) происходить математические операции между ними (BooleanType.js, NumberType.js, StringType.js, IntervalType.js). Благодаря подобной реализации решения задачи: для добавления новой функции достаточно добавить её функционал в Map, а для добавления нового типа переменной – создать новый файл с классом и описать необходимый функционал для операторов.
Зависимость вычислений
Планирование
Реализовав вычисление, оставалось только усовершенствовать класс Таблицы, чтобы он стал поддерживать перерасчет значений в клетках при изменении одной из них. Для улучшения производительности было решено при изменении одной из ячеек изменять не всю таблицу, а только те ячейки, которые могли измениться.
Код
Был частично переписан файл с таблицей – в него были добавлены Map-ы которые хранили таблицы смежности зависимостей каждой клетки как в одну так и в другую сторону (Spreadsheet.js). Также изменения коснулись файла отвечающий за расчет значений, чтобы он находил в формуле зависимости у клеток и обновлял их (TreeRunner.js).
Заключение
Выполненные задачи
1.	Клиентская часть позволяет выполнять операции с ячейками, описанные в задачах 1, 2, 3
2.	Серверная часть была полностью спроектирована и реализована, чтобы выполнять задачу 4.
Невыполненные задачи
Несмотря на то, что клиентская и серверная часть были разработаны, не было выполнено их связывание, поэтому на данный момент нет возможности сохранять таблицы на сервере. Однако есть возможность регистрироваться, авторизоваться и создавать пустые таблицы.
Дальнейшее развитие проекта
Ниже описан возможный путь дальнейшего развития проекта:
1.	Связывание клиентской части с уже реализованной серверной
2.	Добавление функций, отличающих продукт от конкурирующих (Google таблицы, Microsoft Excel). Одной из таких функций может стать слияние нескольких таблиц в одну. Данная функция присутствует в реляционных базах данных, а учитывая возможность применения электронных таблиц в качестве подобного хранилища, такая функция была бы вполне уместна. Принципы работы можно заимствовать у конструкции JOIN  из SQL.
3.	Разработка модели монетизации проекта. В качестве модели может служить:
1.	Платные функции, доступные по подписке
2.	Платная поддержка бизнес-клиентам
4.	Развёртывание рекламной кампании в соответствии с выбранной моделью монетизации.
