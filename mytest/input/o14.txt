Федеральное государственное бюджетное образовательное учреждение
высшего профессионального образования
«Московский государственный технический университет имени    Н. Э. Баумана»
(МГТУ им. Н. Э. Баумана)



Факультет: Информатика и системы управления

Кафедра: Теоретическая информатика и компьютерные технологии







Лабораторная работа №7
«Разработка клиент-серверного приложения на основе сокетов на языке С»
по курсу: «КОМПЬЮТЕРНЫЕ СЕТИ»






Выполнил:
Студент группы ИУ9-32Б
Жук Д. О.

Проверил: 
Посевин Д. П.


 
1.	Цель.
Целью данной лабораторной работы является разработка клиент-серверного приложения на основе сокетов в языке С.
2.	Условия задачи.
Реализовать клиент-серверное приложение на основе сокетов в языке C. Возвращать длину полученной строки.
server/server.cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <ctype.h>

const int maxSizeBuff = 1024;

void algorithm(int connfd)
{
    int res;
    char recvBuff[maxSizeBuff + 1];
    char sendBuff[maxSizeBuff + 1];
    while (1)
    {
        while ((res = recv(connfd, recvBuff, maxSizeBuff, 0)) == 0)
            ;
        if (res < 0)
        {
            fprintf(stderr, "recv error\n");
            return;
        }
        recvBuff[res] = 0;
        if ((strncmp(recvBuff, "exit\0", 5)) == 0)
        {
            printf("Client Exit...\n");
            break;
        }

        // ===============================================

        snprintf(sendBuff, maxSizeBuff, "%ld", strlen(recvBuff));

        // ===============================================

        res = send(connfd, sendBuff, strlen(sendBuff) + 1, 0);
        if (res < 0)
        {
            fprintf(stderr, "send error\n");
            return;
        }
    }
}

int main(int argc, char *argv[])
{
    struct sockaddr_in serv_addr = {
        AF_INET,
        htons(3012),
        {inet_addr("127.0.0.1")}};
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd < 0)
    {
        fprintf(stderr, "socket error\n");
        return 1;
    }
    int res = bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    if (res < 0)
    {
        fprintf(stderr, "bind error\n");
        return 1;
    }
    res = listen(listenfd, 10);
    if (res < 0)
    {
        fprintf(stderr, "listen error\n");
        return 1;
    }

    int connfd;
    struct sockaddr_in client_addr;
    int client_addr_size = sizeof(client_addr);
    while (1)
    {
        connfd = accept(listenfd, (struct sockaddr *)&client_addr, &client_addr_size);
        if (connfd < 0)
        {
            fprintf(stderr, "accept error\n");
            return 1;
        }
        fprintf(stderr, "start connection\n");
        algorithm(connfd);
        close(connfd);
        fprintf(stderr, "close connection\n");
    }
}

client/client.cpp
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
    const int maxSizeBuff = 1024;
    int sockfd = 0;
    char recvBuff[maxSizeBuff];
    char sendBuff[maxSizeBuff + 1];
    struct sockaddr_in serv_addr = {
        AF_INET,
        htons(atoi(argv[2])),
        {inet_addr(argv[1])}};

    if (argc != 3)
    {
        printf("\n Usage: %s <ip-server> <port> \n", argv[0]);
        return 1;
    }

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("\n Error : Could not create socket \n");
        return 1;
    }

    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
        printf("\n Error : Connect Failed \n");
        return 1;
    }

    int res;
    while (1)
    {
        int sizeSendBuff = 0;
        scanf("%s", sendBuff);
        res = send(sockfd, sendBuff, strlen(sendBuff) + 1, 0);
        if (res < 0)
        {
            fprintf(stderr, "send error\n");
            break;
        }
        if ((strncmp(sendBuff, "exit", 4)) == 0)
        {
            printf("Exit...\n");
            break;
        }

        while ((res = recv(sockfd, recvBuff, maxSizeBuff, 0)) == 0)
            ;
        if (res < 0)
        {
            fprintf(stderr, "recv error\n");
            break;
        }
        recvBuff[res] = 0;
        fprintf(stdout, "%s\n", recvBuff);
    }

    if (res < 0)
    {
        printf("\n Read error \n");
    }

    return 0;
}


