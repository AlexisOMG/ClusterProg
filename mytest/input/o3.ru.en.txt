Federal State Budgetary Educational Institution
higher professional education
"Moscow State Technical University named after N. E. Bauman"
(MSTU. Bauman)



Faculty: Computer Science and Control Systems

Department: Theoretical Informatics and Computer Technologies







Laboratory work No. 8
"Developing a class template"
on the course: "LANGUAGES AND PROGRAMMING METHODS"







Completed:
Student of group IU9-22B
Zhuk D.O.

Checked: 
Posevin D.P.


 
1. Purpose.
The purpose of this work is to study the capabilities of the C ++ language that provide the application of operation signs to objects of user-defined types.
2. Problem conditions.
In C ++, implement a class template (MergingMap <K, V>), which is an associative array that maps keys of type K to values ​​of type V.
Class V requirement:
1. the presence of a constructor that takes an integer as a parameter and, if this number is equal to 0, generates some value that plays the role of "zero" for type V;
2. the presence of a binary operation "+", which allows you to somehow obtain the "sum" of two values ​​(it is assumed that this operation is associative, and the above "zero" is a neutral element relative to it).
Note that the primitive numeric types of the C ++ language satisfy the requirements for the class V and can be used to test the functionality of the MergingMap <K, V> class. Operations to be overloaded for MergingMap <K, V>:
1. "[]" - returns a reference to the value associated with the specified key (if there is no dictionary pair with the specified key in the associative array, such a pair is automatically added to the array, and its value becomes "zero");
2. "+" - union of two associative arrays A and B, the result of which is an associative array containing such word pairs hk, vi that k is a key in at least one of the combined arrays, and v = A [k] + B [ k].
3. "==", "! =".
The constructor of the MergingMap <K, V> class must take an integer as a parameter and create an empty associative array. The constructor parameter can either be ignored or treated as the predicted size of the associative array for more efficient memory allocation.
The functionality of the MergingMap template should be checked for the cases of MergingMap <string, int> and MergingMap <string, MergingMap <string, int >>. 
 
4. Solution.
MergingMap.h
#pragma once
#include <iostream>
#include <string>
#include <vector>

using namespace std;

#define vec vector

template <class K, class V>
class MergingMap {
 vec <K> keys;
 vec <V> vals;

public:
 MergingMap (int max_size);
 MergingMap ();

 int size () const;
 K getKey (int i) const;
 V getVal (int i) const;

 int findIndex (K key) const;

 V & operator [] (K key);

 MergingMap <K, V> & operator + = (const MergingMap <K, V> & other);

 bool operator == (const MergingMap <K, V> & other) const;

 bool operator! = (const MergingMap <K, V> & other) const;

 operator string ();
};

template <class K, class V>
MergingMap <K, V> operator + (MergingMap <K, V> left, const MergingMap <K, V> & right);

template <class K, class V>
ostream & operator << (ostream & out, const MergingMap <K, V> & map);

MergingMap.cpp

#include "MergingMap.h"

template <class K, class V>
MergingMap <K, V> :: MergingMap (int max_size) {
 keys.reserve (max_size);
 vals.reserve (max_size);
}

template <class K, class V>
MergingMap <K, V> :: MergingMap (): MergingMap (10) {}

template <class K, class V>
int MergingMap <K, V> :: size () const {return keys.size (); }

template <class K, class V>
K MergingMap <K, V> :: getKey (int i) const {return keys [i]; }

template <class K, class V>
V MergingMap <K, V> :: getVal (int i) const {return vals [i]; }

template <class K, class V>
int MergingMap <K, V> :: findIndex (K key) const {
 int l = -1, r = size ();
 while (r - l> 1) {
 int m = (l + r) / 2;
 if (keys [m] == key) return m;
 if (keys [m] <key) l = m;
 else r = m;
 }
 return l;
}

template <class K, class V>
V & MergingMap <K, V> :: operator [] (K key) {
 int ind = findIndex (key);
 if (ind> = 0 && keys [ind] == key) return vals [ind];
 keys.push_back (key);
 vals.push_back (V (0));
 for (int i = ind + 1; i <size () - 1; i ++) {
 swap (keys [i], keys [size () - 1]);
 swap (vals [i], vals [size () - 1]);
 }
 return vals [ind + 1];
}

template <class K, class V>
MergingMap <K, V> & MergingMap <K, V> :: operator + = (const MergingMap <K, V> & other) {
 for (int i = 0; i <other.size (); i ++)
 this-> operator [] (other.getKey (i)) + = other.getVal (i);
 return * this;
}

template <class K, class V>
bool MergingMap <K, V> :: operator == (const MergingMap <K, V> & other) const {
 int i = 0, j = 0;
 while (true) {
 while (i <size () && vals [i] == V ()) i ++;
 while (j <other.size () && other.vals [j] == V ()) j ++;
 if (i == size () && j == other.size ()) return true;
 if (i == size () || j == other.size ()) return false;
 if (keys [i]! = other.keys [j]
|| vals [i ++]! = other.vals [j ++]) return false;
 }
}

template <class K, class V>
bool MergingMap <K, V> :: operator! = (const MergingMap <K, V> & other) const {
 return! (* this == other);
}

template <class K, class V>
MergingMap <K, V> :: operator string () {
 string retVal = "";
 for (int i = 0; i <size (); i ++)
 {
 retVal + = (string) keys [i];
 retVal + = (string) vals [i];
 }

 return retVal;
}

template <class K, class V>
MergingMap <K, V> operator + (MergingMap <K, V> left, const MergingMap <K, V> & right) {
 left + = right;
 return left;
}

template <class K, class V>
ostream & operator << (ostream & out, const MergingMap <K, V> & map)
{
 out << '{';
 bool ch = false;
 for (int i = 0; i <map.size (); i ++) {
 if (map.getVal (i) == V ()) continue;
 if (ch) out << ",";
 out << '[' << map.getKey (i) << "->" << map.getVal (i) << ']';
 ch = true;
 }
 return out << '}';
}

main.cpp

#include "MergingMap.cpp"

#define str string

template <class C>
void CheckAns (C val, C trueVal) {
 cout << (val == trueVal? "true": "FALSE") << endl;
}

int main ()
{
 MergingMap <str, int> map1, map2;

 map1 ["12"] = 12;
 map1 ["45"] = 45;
 map1 ["45"] * = -1;

 cout << "1)" << endl;

 CheckAns (map1 ["45"], -45);
 CheckAns (map1 ["12"], 12);
 CheckAns (map1 ["MGTU - top!"], 0);

 cout << "2)" << endl;

 map2 ["45"] = -45;
 map2 ["12"] = -12;
 cout << "map1 =" << map1 << endl;
 cout << "map2 =" << map2 << endl;
 CheckAns (map2 == map1, false);

 map2 ["12"] * = -1;
 cout << "map1 =" << map1 << endl;
 cout << "map2 =" << map2 << endl;
 CheckAns (map2 == map1, true);

 cout << "3)" << endl;

 MergingMap <str, MergingMap <str, int >> bigmap;

 bigmap ["map1"] = map1;
 bigmap ["map1"] ["inf"] = 1000;
 bigmap ["map2"] = map2;
 bigmap ["map2"] ["abc"] = 123;
 bigmap ["sum (map1, map2)"] = bigmap ["map1"] + bigmap ["map2"];
 cout << bigmap << endl;
}
 
5. Results of execution

 

6. Server
Path to the program executable file on the lab2.posevin.com server:
 /home/zhuk/lab9/prog.exe
