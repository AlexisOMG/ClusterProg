Federal State Budgetary Educational Institution
higher professional education
"Moscow State Technical University named after N. E. Bauman"
(MSTU. Bauman)



Faculty: Computer Science and Control Systems

Department: Theoretical Informatics and Computer Technologies







Laboratory work No. 7
"Development of a client-server application based on sockets in the C language"
at the rate: "COMPUTER NETWORKS"






Completed:
Student of group IU9-32B
Zhuk D.O.

Checked: 
Posevin D.P.


â€ƒ
1. Purpose.
The goal of this lab is to develop a client-server application based on sockets in the C language.
2. Problem conditions.
Implement a socket-based client / server application in C. Return the length of the resulting string.
server / server.cpp
#include <sys / socket.h>
#include <netinet / in.h>
#include <arpa / inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys / types.h>
#include <ctype.h>

const int maxSizeBuff = 1024;

void algorithm (int connfd)
{
 int res;
 char recvBuff [maxSizeBuff + 1];
 char sendBuff [maxSizeBuff + 1];
 while (1)
 {
 while ((res = recv (connfd, recvBuff, maxSizeBuff, 0)) == 0)
 ;
 if (res <0)
 {
 fprintf (stderr, "recv error \ n");
 return;
 }
 recvBuff [res] = 0;
 if ((strncmp (recvBuff, "exit \ 0", 5)) == 0)
 {
 printf ("Client Exit ... \ n");
 break;
 }

 // ===============================================

 snprintf (sendBuff, maxSizeBuff, "% ld", strlen (recvBuff));

 // ===============================================

 res = send (connfd, sendBuff, strlen (sendBuff) + 1, 0);
 if (res <0)
 {
 fprintf (stderr, "send error \ n");
 return;
 }
 }
}

int main (int argc, char * argv [])
{
 struct sockaddr_in serv_addr = {
 AF_INET,
 htons (3012),
 {inet_addr ("127.0.0.1")}};
 int listenfd = socket (AF_INET, SOCK_STREAM, 0);
 if (listenfd <0)
 {
 fprintf (stderr, "socket error \ n");
 return 1;
 }
 int res = bind (listenfd, (struct sockaddr *) & serv_addr, sizeof (serv_addr));
 if (res <0)
 {
 fprintf (stderr, "bind error \ n");
 return 1;
 }
 res = listen (listenfd, 10);
 if (res <0)
 {
 fprintf (stderr, "listen error \ n");
 return 1;
 }

 int connfd;
 struct sockaddr_in client_addr;
 int client_addr_size = sizeof (client_addr);
 while (1)
 {
 connfd = accept (listenfd, (struct sockaddr *) & client_addr, & client_addr_size);
 if (connfd <0)
 {
 fprintf (stderr, "accept error \ n");
 return 1;
 }
 fprintf (stderr, "start connection \ n");
 algorithm (connfd);
 close (connfd);
 fprintf (stderr, "close connection \ n");
 }
}

client / client.cpp
#include <sys / socket.h>
#include <sys / types.h>
#include <netinet / in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <arpa / inet.h>

int main (int argc, char * argv [])
{
 const int maxSizeBuff = 1024;
 int sockfd = 0;
 char recvBuff [maxSizeBuff];
 char sendBuff [maxSizeBuff + 1];
 struct sockaddr_in serv_addr = {
 AF_INET,
 htons (atoi (argv [2])),
 {inet_addr (argv [1])}};

 if (argc! = 3)
 {
 printf ("\ n Usage:% s <ip-server> <port> \ n", argv [0]);
 return 1;
 }

 if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0)
 {
 printf ("\ n Error: Could not create socket \ n");
 return 1;
 }

 if (connect (sockfd, (struct sockaddr *) & serv_addr, sizeof (serv_addr)) <0)
 {
 printf ("\ n Error: Connect Failed \ n");
 return 1;
 }

 int res;
 while (1)
 {
 int sizeSendBuff = 0;
 scanf ("% s", sendBuff);
 res = send (sockfd, sendBuff, strlen (sendBuff) + 1, 0);
 if (res <0)
 {
 fprintf (stderr, "send error \ n");
 break;
 }
 if ((strncmp (sendBuff, "exit", 4)) == 0)
 {
 printf ("Exit ... \ n");
 break;
 }

 while ((res = recv (sockfd, recvBuff, maxSizeBuff, 0)) == 0)
 ;
 if (res <0)
 {
 fprintf (stderr, "recv error \ n");
 break;
 }
 recvBuff [res] = 0;
 fprintf (stdout, "% s \ n", recvBuff);
 }

 if (res <0)
 {
 printf ("\ n Read error \ n");
 }

 return 0;
}


